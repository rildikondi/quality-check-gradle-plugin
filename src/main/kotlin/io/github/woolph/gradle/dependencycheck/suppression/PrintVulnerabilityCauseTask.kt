/* Copyright 2023 ENGEL Austria GmbH */
package io.github.woolph.gradle.dependencycheck.suppression

import io.github.woolph.gradle.util.asFileIfExists
import io.github.woolph.gradle.util.children
import io.github.woolph.gradle.util.get
import io.github.woolph.gradle.util.processXml
import org.gradle.api.DefaultTask
import org.gradle.api.artifacts.ResolvedConfiguration
import org.gradle.api.artifacts.ResolvedDependency
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.TaskAction

abstract class PrintVulnerabilityCauseTask : DefaultTask() {
    @get:InputFiles abstract val dependencyCheckXmlReport: RegularFileProperty

    init {
        group = "verification/dependency-check"

        dependencyCheckXmlReport.convention(
            project.layout.buildDirectory.file("reports/dependency-check-junit.xml"),
        )
    }

    data class VulnerabilityCause(
        val moduleString: String,
        val vulnerabilities: List<Vulnerability>,
    )

    @TaskAction
    fun printVulnerabilityCause() {
        logger.debug("printVulnerabilityCause: task started")

        val dependencyCauses =
            project.configurations
                .getByName("runtimeClasspath")
                .resolvedConfiguration
                .getDependencyCause()
                .mapKeys { it.key.module.toString() }

        logger.debug("printVulnerabilityCause: determined dependency causes")

        val vulnerabilities =
            dependencyCheckXmlReport.asFileIfExists?.processXml { doc ->
                doc.children().flatMap { testsuites ->
                    testsuites
                        .children()
                        .filter { (it.attributes["failures"]?.value?.toInt() ?: 0) > 0 }
                        .children()
                        .mapNotNull { testcase ->
                            testcase.attributes["classname"]?.value?.let { vulnerability ->
                                VulnerabilityCause(
                                    testcase.attributes["name"]?.value?.toModuleString()
                                        ?: "unknown",
                                    listOf(
                                        Vulnerability(
                                            VulnerabilityType.VulnerabilityName,
                                            vulnerability)), // TODO determine correct
                                    // VulnerabilityType
                                )
                            }
                        }
                }
            }

        logger.debug("printVulnerabilityCause: starting to process the xml of dependency issues")

        vulnerabilities?.forEach {
            val cause = dependencyCauses[it.moduleString] ?: emptySet()
            logger.warn(
                "${cause.map { it.module }} introduced ${it.moduleString} with the ${it.vulnerabilities.map { it.name }}")
        }
    }

    fun ResolvedConfiguration.getDependencyCause():
        Map<ResolvedDependency, Set<ResolvedDependency>> {
        return sequence {
                firstLevelModuleDependencies.forEach { causingDependency ->
                    causingDependency.children.forEach { addChildren(it, causingDependency) }
                }
            }
            .groupBy(
                Pair<ResolvedDependency, ResolvedDependency>::first,
                Pair<ResolvedDependency, ResolvedDependency>::second)
            .mapValues { it.value.toSet() }
    }

    suspend fun SequenceScope<Pair<ResolvedDependency, ResolvedDependency>>.addChildren(
        childDependency: ResolvedDependency,
        causingDependency: ResolvedDependency
    ) {
        yield(childDependency to causingDependency)
        childDependency.children.forEach { addChildren(it, causingDependency) }
    }
}
